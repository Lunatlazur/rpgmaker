declare namespace RPGMakerMV {
    type ActorIteratorCallback = (actor: DataActor, index?: number, partyMembers?: DataActor[]) => void
    type EnemyIteratorCallback = (actor: DataEnemy, index?: number, troopMembers?: DataEnemy[]) => void

    type DefaultLetterTableHalf = [
        ' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',' K',' L',' M',
        ' N',' O',' P',' Q',' R',' S',' T',' U',' V',' W',' X',' Y',' Z'
    ]
    type DefaultLetterTableFull = [
        'Ａ','Ｂ','Ｃ','Ｄ','Ｅ','Ｆ','Ｇ','Ｈ','Ｉ','Ｊ','Ｋ','Ｌ','Ｍ',
        'Ｎ','Ｏ','Ｐ','Ｑ','Ｒ','Ｓ','Ｔ','Ｕ','Ｖ','Ｗ','Ｘ','Ｙ','Ｚ'
    ]
}

declare class Game_Temp {
    constructor();
    initialize(): void;
    isPlaytest(): boolean;
    reserveCommonEvent(commonEventId: number): void;
    clearCommonEvent(): void;
    isCommonEventReserved(): boolean;
    reservedCommonEvent(): RPGMakerMV.DataCommonEvent;
    setDestination(x: number, y: number): void;
    clearDestination(): void;
    isDestinationValid(): void;
    destinationX(): number;
    destinationY(): number;

    _isPlaytest: boolean;
    _commonEventId: number;
    _destinationX: number;
    _destinationY: number;
}

declare class Game_System {
    _saveEnabled: boolean;
    _menuEnabled: boolean;
    _encounterEnabled: boolean;
    _formationEnabled: boolean;
    _battleCount: number;
    _winCount: number;
    _escapeCount: number;
    _saveCount: number;
    _versionId: number;
    _framesOnSave: number;
    _bgmOnSave: IAudioObject;
    _bgsOnSave: IAudioObject;
    _windowTone: number[];
    _battleBgm: RPGMakerMV.Sound;
    _victoryMe: RPGMakerMV.Sound;
    _defeatMe: RPGMakerMV.Sound;
    _savedBgm: RPGMakerMV.Sound;
    _walkingBgm: RPGMakerMV.Sound;

    constructor();
    initialize(): void;
    isJapanese(): boolean;
    isChinese(): boolean;
    isKorean(): boolean;
    isCJK(): boolean;
    isRussian(): boolean;
    isSideView(): boolean;
    isSaveEnabled(): boolean;
    disableSave(): void;
    enableSave(): void;
    isMenuEnabled(): boolean;
    disableMenu(): void;
    enableMenu(): void;
    isEncounterEnabled(): boolean;
    disableEncounter(): void;
    enableEncounter(): void;
    isFormationEnabled(): boolean;
    disableFormation(): void;
    enableFormation(): void;
    battleCount(): number;
    winCount(): number;
    escapeCount(): number;
    saveCount(): number;
    versionId(): number;
    windowTone(): number[];
    setWindowTone(value: number[]): void;
    battleBgm(): RPGMakerMV.Sound;
    setBattleBgm(value: RPGMakerMV.Sound): void;
    victoryMe(): RPGMakerMV.Sound;
    setVictoryMe(value: RPGMakerMV.Sound): void;
    defeatMe(): RPGMakerMV.Sound;
    setDefeatMe(value: RPGMakerMV.Sound): void;
    onBattleStart(): void;
    onBattleWin(): void;
    onBattleEscape(): void;
    onBeforeSave(): void;
    onAfterLoad(): void;
    playtime(): number;
    playtimeText(): string;
    saveBgm(): void;
    replayBgm(): void;
    saveWalkingBgm(): void;
    replayWalkingBgm(): void;
    saveWalkingBgm2(): void;
}

declare class Game_Timer {
    _frames: number;
    _working: boolean;

    constructor();
    initialize(): void;
    update(sceneActive: boolean): void;
    start(count: number): void;
    stop(): void;
    isWorking(): boolean;
    seconds(): number;
    onExpire(): void;
}

declare class Game_Message {
    _texts: string[];
    _choices: string[];
    _faceName: string;
    _faceIndex: number;
    _background: number;
    _positionType: number;
    _choiceDefaultType: number;
    _choiceCancelType: number;
    _choiceBackground: number;
    _choicePositionType: number;
    _numInputVariableId: number;
    _numInputMaxDigits: number;
    _itemChoiceVariableId: number;
    _itemChoiceItypeId: number;
    _scrollMode: boolean;
    _scrollSpeed: number;
    _scrollNoFast: boolean;
    _choiceCallback: Function;

    constructor();
    initialize(): void;
    clear(): void;
    choices(): string[];
    faceName(): string;
    faceIndex(): number;
    background(): number;
    positionType(): number;
    choiceDefaultType(): number;
    choiceCancelType(): number;
    choiceBackground(): number;
    choicePositionType(): number;
    numInputVariableId(): number;
    numInputMaxDigits(): number;
    itemChoiceVariableId(): number;
    itemChoiceItypeId(): number;
    scrollMode(): boolean;
    scrollSpeed(): number;
    scrollNoFast(): boolean;
    add(text: string): void;
    setFaceImage(faceName: string, faceIndex: number): void;
    setBackground(background: number): void;
    setPositionType(positionType: number): void;
    setChoices(choices: string[], defaultType: number, cancelType: number): void;
    setChoiceBackground(background: number): void;
    setChoicePositionType(positionType: number): void;
    setNumberInput(variableId: number, maxDigits: number): void;
    setItemChoice(variableId: number, itemType: number): void;
    setScroll(speed: number, noFast: boolean): void;
    setChoiceCallback(callback: Function): void;
    onChoice(n: number): void;
    hasText(): boolean;
    isChoice(): boolean;
    isNumberInput(): boolean;
    isItemChoice(): boolean;
    isBusy(): boolean;
    newPage(): void;
    allText(): string;
}

declare class Game_Switches {
    constructor();
    initialize(): void;
    clear(): void;
    value(switchId: number): boolean;
    setValue(switchId: number, value: boolean): void;
    onChange(): void;

    _data: boolean[];
}

declare class Game_Variables {
    constructor();
    initialize(): void;
    clear(): void;
    value(variableId: number): number;
    setValue(variableId: number, value: number): number;
    onChange(): void;

    _data: number[];
}

declare class Game_SelfSwitches {
    constructor();
    initialize(): void;
    clear(): void;
    value(key: number[]): boolean;
    setValue(key: Array<number | string>, value: boolean): void;
    onChange(): void;

    _data: { [key: string]: boolean };
}

declare class Game_Screen {
    _brightness: number;
    _zoomX: number;
    _zoomY: number;
    _zoomScale: number;
    _zoomScaleTarget: number;
    _zoomDuration: number;
    _weatherType: string;
    _weatherPower: number;
    _weatherPowerTarget: number;
    _weatherDuration: number;
    _pictures: Game_Picture[];
    _fadeOutDuration: number;
    _fadeInDuration: number;
    _tone: number[];
    _toneTarget: number[];
    _toneDuration: number;
    _flashColor: number[];
    _flashDuration: number;
    _shake: number;
    _shakePower: number;
    _shakeSpeed: number;
    _shakeDuration: number;

    constructor();
    initialize(): void;
    clear(): void;
    onBattleStart(): void;
    brightness(): number;
    tone(): number[];
    flashColor(): number[];
    shake(): number;
    zoomX(): number;
    zoomY(): number;
    zoomScale(): number;
    weatherType(): string;
    weatherPower(): number;
    picture(pictureId: number): Game_Picture;
    realPictureId(pictureId: number): number;
    clearFade(): void;
    clearTone(): void;
    clearFlash(): void;
    clearShake(): void;
    clearZoom(): void;
    clearWeather(): void;
    clearPictures(): void;
    eraseBattlePictures(): void;
    maxPictures(): number;
    startFadeOut(duration: number): void;
    startFadeIn(duration: number): void;
    startTint(tone: number[], duration: number): void;
    startFlash(color: number[], duration: number): void;
    startShake(power: number, speed: number, duration: number): void;
    startZoom(x: number, y: number, scale: number, duration: number): void;
    setZoom(x: number, y: number, scale: number): void;
    changeWeather(type: string, power: number, duration: number): void;
    update(): void;
    updateFadeOut(): void;
    updateFadeIn(): void;
    updateTone(): void;
    updateFlash(): void;
    updateShake(): void;
    updateZoom(): void;
    updateWeather(): void;
    updatePictures(): void;
    startFlashForDamage(): void;
    showPicture(pictureId: number, name: string, origin: number, x: number, y: number, scaleX: number, scaleY: number, opacity: number, blendMode: number): void;
    movePicture(pictureId: number, origin: number, x: number, y: number, scaleX: number, scaleY: number, opacity: number, blendMode: number, duration: number): void;
    rotatePicture(pictureId: number, speed: number): void;
    tintPicture(pictureId: number, tone: number[], duration: number): void;
    erasePicture(pictureId: number): void;
}

declare class Game_Picture {
    _name: string;
    _origin: number;
    _x: number;
    _y: number;
    _scaleX: number;
    _scaleY: number;
    _opacity: number;
    _blendMode: number;
    _tone: number[];
    _toneTarget: number[];
    _toneDuration: number;
    _angle: number;
    _rotationSpeed: number;
    _targetX: number;
    _targetY: number;
    _targetScaleX: number;
    _targetScaleY: number;
    _targetOpacity: number;
    _duration: number;

    constructor();
    initialize(): void;
    name(): string;
    origin(): number;
    x(): number;
    y(): number;
    scaleX(): number;
    scaleY(): number;
    opacity(): number;
    blendMode(): number;
    tone(): number[];
    angle(): number;
    initBasic(): void;
    initTarget(): void;
    initTone(): void;
    initRotation(): void;
    show(name: string, origin: number, x: number, y: number, scaleX: number, scaleY: number, opacity: number, blendMode: number): void;
    move(origin: number, x: number, y: number, scaleX: number, scaleY: number, opacity: number, blendMode: number, duration: number): void;
    rotate(speed: number): void;
    tint(tone: number[], duration: number): void;
    erase(): void;
    update(): void;
    updateMove(): void;
    updateTone(): void;
    updateRotation(): void;
}

declare class Game_Item {
    _dataClass: string;
    _itemId: number;

    constructor(item?: RPGMakerMV.DataAnyItem | RPGMakerMV.DataSkill);
    initialize(item: RPGMakerMV.DataAnyItem | RPGMakerMV.DataSkill): void;
    isSkill(): boolean;
    isItem(): boolean;
    isUsableItem(): boolean;
    isWeapon(): boolean;
    isArmor(): boolean;
    isEquipItem(): boolean;
    isNull(): boolean;
    itemId(): number;
    object(): RPGMakerMV.DataAnyItem | RPGMakerMV.DataSkill;
    setObject(item: RPGMakerMV.DataAnyItem | RPGMakerMV.DataSkill): void;
    setEquip(isWeapon: boolean, itemId: number): void;
}

declare class Game_Action {
    constructor(subject: Game_Battler, forcing: boolean);

    static EFFECT_RECOVER_HP: 11;
    static EFFECT_RECOVER_MP: 12;
    static EFFECT_GAIN_TP: 13;
    static EFFECT_ADD_STATE: 21;
    static EFFECT_REMOVE_STATE: 22;
    static EFFECT_ADD_BUFF: 31;
    static EFFECT_ADD_DEBUFF: 32;
    static EFFECT_REMOVE_BUFF: 33;
    static EFFECT_REMOVE_DEBUFF: 34;
    static EFFECT_SPECIAL: 41;
    static EFFECT_GROW: 42;
    static EFFECT_LEARN_SKILL: 43;
    static EFFECT_COMMON_EVENT: 44;
    static SPECIAL_EFFECT_ESCAPE: 0;
    static HITTYPE_CERTAIN: 0;
    static HITTYPE_PHYSICAL: 1;
    static HITTYPE_MAGICAL: 2;

    _subjectActorId: number;
    _subjectEnemyIndex: number;
    _forcing: boolean;
    _item: Game_Item;
    _targetIndex: number;

    constructor(subject: Game_Battler, forcing?: boolean);
    initialize(subject: Game_Battler, forcing: boolean): void;
    clear(): void;
    setSubject(subject: Game_Battler): void;
    subject(): Game_Battler;
    friendsUnit(): Game_Unit;
    opponentsUnit(): Game_Unit;
    setEnemyAction(action: boolean): void;
    setAttack(): void;
    setGuard(): void;
    setSkill(skillId: number): void;
    setItem(itemId: number): void;
    setItemObject(object: RPGMakerMV.DataAnyItem | RPGMakerMV.DataSkill): void
    setTarget(targetIndex: number): void;
    item(): RPGMakerMV.DataAnyItem | RPGMakerMV.DataSkill;
    isSkill(): boolean;
    isItem(): boolean;
    numRepeats(): number;
    checkItemScope(list: number[]): boolean;
    isForOpponent(): boolean;
    isForFriend(): boolean;
    isForDeadFriend(): boolean;
    isForUser(): boolean;
    isForOne(): boolean;
    isForRandom(): boolean;
    isForAll(): boolean;
    needsSelection(): boolean;
    numTargets(): number;
    checkDamageType(list: number[]): boolean;
    isHpEffect(): boolean;
    isMpEffect(): boolean;
    isDamage(): boolean;
    isRecover(): boolean;
    isDrain(): boolean;
    isHpRecover(): boolean;
    isMpRecover(): boolean;
    isCertainHit(): boolean;
    isPhysical(): boolean;
    isMagical(): boolean;
    isAttack(): boolean;
    isGuard(): boolean;
    isMagicSkill(): boolean;
    decideRandomTarget(): void;
    setConfusion(): void;
    prepare(): void;
    isValid(): boolean;
    speed(): number;
    makeTargets(): Game_Battler[];
    repeatTargets(targets: Game_Battler[]): Game_Battler[];
    confusionTarget(): Game_Battler;
    targetsForOpponents(): Game_Battler[];
    targetsForFriends(): Game_Battler[];
    evaluate(): number;
    itemTargetCandidates(): Game_Battler[];
    evaluateWithTarget(target: Game_Battler): number;
    testApply(target: Game_Battler): boolean;
    hasItemAnyValidEffects(target: Game_Battler): number;
    testItemEffect(target: Game_Battler, effect: RPGMakerMV.Effect): number;
    itemCnt(target: Game_Battler): number;
    itemMrf(target: Game_Battler): number;
    itemHit(target: Game_Battler): number;
    itemEva(target: Game_Battler): number;
    itemCri(target: Game_Battler): number;
    apply(target: Game_Battler): void;
    makeDamageValue(target: Game_Battler, critical: boolean): number;
    evalDamageFormula(target: Game_Battler): number;
    calcElementRate(target: Game_Battler): number;
    elementsMaxRate(target: Game_Battler, elements: number[]): number;
    applyCritical(damage: number): number;
    applyVariance(damage: number, variance: number): number;
    applyGuard(damage: number, target: Game_Battler): number;
    executeDamage(target: Game_Battler, value: number): void;
    executeHpDamage(target: Game_Battler, value: number): void;
    executeMpDamage(target: Game_Battler, value: number): void;
    gainDrainedHp(value: number): void;
    gainDrainedMp(value: number): void;
    applyItemEffect(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectRecoverHp(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectRecoverMp(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectGainTp(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectAddState(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectAddAttackState(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectAddNormalState(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectRemoveState(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectAddBuff(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectAddDebuff(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectRemoveBuff(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectRemoveDebuff(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectSpecial(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectGrow(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectLearnSkill(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    itemEffectCommonEvent(target: Game_Battler, effect: RPGMakerMV.Effect): void;
    makeSuccess(target: Game_Battler): void;
    applyItemUserEffect(target: Game_Battler): void;
    lukEffectRate(target: Game_Battler): number;
    applyGlobal(): void;
}

declare class Game_ActionResult {
    used: boolean;
    missed: boolean;
    evaded: boolean;
    physical: boolean;
    drain: boolean;
    critical: boolean;
    success: boolean;
    hpAffected: boolean;
    hpDamage: number;
    mpDamage: number;
    tpDamage: number;
    addedStates: RPGMakerMV.DataState[];
    removedStates: RPGMakerMV.DataState[];
    addedBuffs: number[];
    addedDebuffs: number[];
    removedBuffs: number[];

    constructor();
    initialize(): void;
    clear(): void;
    addedStateObjects(): RPGMakerMV.DataState[];
    removedStateObjects(): RPGMakerMV.DataState[];
    isStatusAffected(): boolean;
    isHit(): boolean;
    isStateAdded(stateId: number): boolean;
    pushAddedState(stateId: number): void;
    isStateRemoved(stateId: number): boolean;
    pushRemovedState(stateId: number): void;
    isBuffAdded(paramId: number): boolean;
    pushAddedBuff(paramId: number): void;
    isDebuffAdded(paramId: number): boolean;
    pushAddedDebuff(paramId: number): void;
    isBuffRemoved(paramId: number): boolean;
    pushRemovedBuff(paramId: number): void;
}

declare class Game_BattlerBase {
    static TRAIT_ELEMENT_RATE: 11;
    static TRAIT_DEBUFF_RATE: 12;
    static TRAIT_STATE_RATE: 13;
    static TRAIT_STATE_RESIST: 14;
    static TRAIT_PARAM: 21;
    static TRAIT_XPARAM: 22;
    static TRAIT_SPARAM: 23;
    static TRAIT_ATTACK_ELEMENT: 31;
    static TRAIT_ATTACK_STATE: 32;
    static TRAIT_ATTACK_SPEED: 33;
    static TRAIT_ATTACK_TIMES: 34;
    static TRAIT_STYPE_ADD: 41;
    static TRAIT_STYPE_SEAL: 42;
    static TRAIT_SKILL_ADD: 43;
    static TRAIT_SKILL_SEAL: 44;
    static TRAIT_EQUIP_WTYPE: 51;
    static TRAIT_EQUIP_ATYPE: 52;
    static TRAIT_EQUIP_LOCK: 53;
    static TRAIT_EQUIP_SEAL: 54;
    static TRAIT_SLOT_TYPE: 55;
    static TRAIT_ACTION_PLUS: 61;
    static TRAIT_SPECIAL_FLAG: 62;
    static TRAIT_COLLAPSE_TYPE: 63;
    static TRAIT_PARTY_ABILITY: 64;
    static FLAG_ID_AUTO_BATTLE: 0;
    static FLAG_ID_GUARD: 1;
    static FLAG_ID_SUBSTITUTE: 2;
    static FLAG_ID_PRESERVE_TP: 3;
    static ICON_BUFF_START: 32;
    static ICON_DEBUFF_START: 48;

    hp: number;
    mp: number;
    tp: number;
    mhp: number;
    mmp: number;
    atk: number;
    def: number;
    mat: number;
    mdf: number;
    agi: number;
    luk: number;
    hit: number;
    eva: number;
    cri: number;
    cev: number;
    mev: number;
    mrf: number;
    cnt: number;
    hrg: number;
    mrg: number;
    trg: number;
    tgr: number;
    grd: number;
    rec: number;
    pha: number;
    mcr: number;
    tcr: number;
    pdr: number;
    mdr: number;
    fdr: number;
    exr: number;

    _hp: number;
    _mp: number;
    _tp: number;
    _hidden: boolean;
    _paramPlus: number[];
    _states: number[];
    _stateTurns: { [key: number]: number };
    _buffs: number[];
    _buffTurns: number[];

    constructor();
    initialize(): void;
    initMembers(): void;
    clearParamPlus(): void;
    clearStates(): void;
    eraseState(stateId: number): void;
    isStateAffected(stateId: number): boolean;
    isDeathStateAffected(): boolean;
    deathStateId(): number;
    deathStateId(stateId: number): void;
    resetStateCounts(stateId: number): void;
    isStateExpired(stateId: number): boolean;
    updateStateTurns(): void;
    clearBuffs(): void;
    eraseBuff(paramId: number): void;
    buffLength(): number;
    buff(paramId: number): number;
    isBuffAffected(paramId: number): boolean;
    isDebuffAffected(paramId: number): boolean;
    isBuffOrDebuffAffected(paramId: number): boolean;
    isMaxBuffAffected(paramId: number): boolean;
    isMaxDebuffAffected(paramId: number): boolean;
    increaseBuff(paramId: number): void;
    decreaseBuff(paramId: number): void;
    overwriteBuffTurns(paramId: number, turns: number): void;
    isBuffExpired(paramId: number): boolean;
    updateBuffTurns(): void;
    die(): void;
    revive(): void;
    states(): RPGMakerMV.DataState[];
    stateIcons(): number[];
    buffIcons(): number[];
    buffIconIndex(buffLevel: number, paramId: number): number;
    allIcons(): number[];
    traitObjects(): RPGMakerMV.DataState[];
    allTraits(): RPGMakerMV.Trait[];
    traits(code: number): RPGMakerMV.Trait[];
    traitsWithId(code: number, id: number): RPGMakerMV.Trait[];
    traitsPi(code: number, id: number): number;
    traitsSum(code: number, id: number): number;
    traitsSumAll(code: number): number;
    traitsSet(code: number): number[];
    paramBase(paramId: number): number;
    paramPlus(paramId: number): number;
    paramMin(paramId: number): number;
    paramMax(paramId: number): number;
    paramRate(paramId: number): number;
    paramBuffRate(paramId: number): number;
    param(paramId: number): number;
    xparam(xparamId: number): number;
    sparam(sparamId: number): number;
    elementRate(elementId: number): number;
    debuffRate(paramId: number): number;
    stateRate(stateId: number): number;
    stateResistSet(): number[];
    isStateResist(stateId: number): boolean;
    attackElements(): number[];
    attackStates(): number[];
    attackStatesRate(stateId: number): number;
    attackSpeed(): number;
    attackTimesAdd(): number;
    addedSkillTypes(): number[];
    isSkillTypeSealed(stypeId: number): boolean;
    addedSkills(): number[];
    isSkillSealed(skillId: number): boolean;
    isEquipWtypeOk(wtypeId: number): boolean;
    isEquipAtypeOk(atypeId: number): boolean;
    isEquipTypeLocked(etypeId: number): boolean;
    isEquipTypeSealed(etypeId: number): boolean;
    slotType(): number;
    isDualWield(): boolean;
    actionPlusSet(): number[];
    specialFlag(flagId: number): boolean;
    collapseType(): number;
    partyAbility(abilityId: number): boolean;
    isAutoBattle(): boolean;
    isGuard(): boolean;
    isSubstitute(): boolean;
    isPreserveTp(): boolean;
    addParam(paramId: number, value: number): void;
    setHp(hp: number): void;
    setMp(mp: number): void;
    setTp(tp: number): void;
    maxTp(): number;
    refresh(): void;
    recoverAll(): void;
    hpRate(): number;
    mpRate(): number;
    tpRate(): number;
    hide(): void;
    appear(): void;
    isHidden(): boolean;
    isAppeared(): boolean;
    isDead(): boolean;
    isAlive(): boolean;
    isDying(): boolean;
    isRestricted(): boolean;
    canInput(): boolean;
    canMove(): boolean;
    isConfused(): boolean;
    confusionLevel(): number;
    isActor(): boolean;
    isEnemy(): boolean;
    sortStates(): void;
    restriction(): number;
    addNewState(stateId: number): void;
    onRestrict(): void;
    mostImportantStateText(): string;
    stateMotionIndex(): number;
    stateOverlayIndex(): number;
    isSkillWtypeOk(skill: RPGMakerMV.DataSkill): boolean;
    skillMpCost(skill: RPGMakerMV.DataSkill): number;
    skillTpCost(skill: RPGMakerMV.DataSkill): number;
    canPaySkillCost(skill: RPGMakerMV.DataSkill): boolean;
    paySkillCost(skill: RPGMakerMV.DataSkill): void;
    isOccasionOk(item: RPGMakerMV.DataAnyItem): boolean;
    meetsUsableItemConditions(item: RPGMakerMV.DataAnyItem): boolean;
    meetsSkillConditions(skill: RPGMakerMV.DataSkill): boolean;
    meetsItemConditions(skill: RPGMakerMV.DataSkill): boolean;
    canUse(item: RPGMakerMV.DataAnyItem): boolean;
    canEquip(item: RPGMakerMV.DataAnyItem): boolean;
    canEquipWeapon(item: RPGMakerMV.DataWeapon): boolean;
    canEquipArmor(item: RPGMakerMV.DataArmor): boolean;
    attackSkillId(): number;
    guardSkillId(): number;
    canAttack(): boolean;
    canGuard(): boolean;
}

declare interface IGame_BattlerAnimation {
    animationId: string;
    mirror: boolean;
    delay: number;
}

declare class Game_Battler extends Game_BattlerBase {
    _actions: Game_Action[];
    _speed: number;
    _result: Game_ActionResult;
    _actionState: string;
    _lastTargetIndex: number;
    _animations: IGame_BattlerAnimation[];
    _damagePopup: boolean;
    _effectType: string;
    _motionType: string;
    _weaponImageId: number;
    _motionRefresh: boolean;
    _selected: boolean;

    constructor();
    initialize(): void;
    initMembers(): void;
    clearAnimations(): void;
    clearDamagePopup(): void;
    clearWeaponAnimation(): void;
    clearEffect(): void;
    clearMotion(): void;
    requestEffect(effectType: string): void;
    requestMotion(motionType: string): void;
    requestMotionRefresh(): void;
    select(): void;
    deselect(): void;
    isAnimationRequested(): boolean;
    isDamagePopupRequested(): boolean;
    isEffectRequested(): boolean;
    isMotionRequested(): boolean;
    isWeaponAnimationRequested(): boolean;
    isMotionRefreshRequested(): boolean;
    isSelected(): boolean;
    effectType(): string;
    motionType(): string;
    weaponImageId(): number;
    shiftAnimation(): IGame_BattlerAnimation;
    startAnimation(animationId: number, mirror: boolean, delay: number): void;
    startDamagePopup(): void;
    startWeaponAnimation(weaponImageId: number): void;
    action(index: number): Game_Action;
    setAction(index: number, action: Game_Action): void;
    numActions(): number;
    clearActions(): void;
    result(): Game_ActionResult;
    clearResult(): void;
    refresh(): void;
    addState(stateId: number): void;
    isStateAddable(stateId: number): boolean;
    isStateRestrict(stateId: number): boolean;
    onRestrict(): void;
    removeState(stateId: number): void;
    escape(): void;
    addBuff(paramId: number, turns: number): void;
    addDebuff(paramId: number, turns: number): void;
    removeBuff(paramId: number): void;
    removeBattleStates(): void;
    removeAllBuffs(): void;
    removeStatesAuto(timing: number): void;
    removeBuffsAuto(): void;
    removeStatesByDamage(): void;
    makeActionTimes(): number;
    makeActions(): void;
    speed(): number;
    makeSpeed(): void;
    currentAction(): Game_Action;
    removeCurrentAction(): void;
    setLastTarnget(target: Game_Battler): void
    forceAction(skillId: number, targetIndex: number): void;
    useItem(item: RPGMakerMV.DataAnyItem): void;
    consumeItem(item: RPGMakerMV.DataAnyItem): void;
    gainHp(value: number): void;
    gainMp(value: number): void;
    gainTp(value: number): void;
    gainSilentTp(value: number): void;
    initTp(): void;
    clearTp(): void;
    chargeTpByDamage(damageRate: number): void;
    regenerateHp(): void;
    maxSlipDamage(): number;
    regenerateMp(): void;
    regenerateTp(): void;
    regenerateAll(): void;
    onBattleStart(): void;
    onAllActionsEnd(): void;
    onTurnEnd(): void;
    onBattleEnd(): void;
    onDamage(value: number): void;
    setActionState(actionState: string): void;
    isUndecided(): boolean;
    isInputting(): boolean;
    isWaiting(): boolean;
    isActing(): boolean;
    isChanting(): boolean;
    isGuardWaiting(): boolean;
    performActionStart(action: Game_Action): void;
    performAction(action: Game_Action): void;
    performActionEnd(): void;
    performDamage(): void;
    performMiss(): void;
    performRecovery(): void;
    performEvasion(): void;
    performMagicEvasion(): void;
    performCounter(): void;
    performReflection(): void;
    performSubstitute(target: Game_Battler): void;
    performCollapse(): void;
}

declare class Game_Actor extends Game_Battler {
    level: number;

    _actorId: number;
    _name: string;
    _nickname: string;
    _classId: number;
    _level: number;
    _characterName: string;
    _characterIndex: number;
    _faceName: string;
    _faceIndex: number;
    _battlerName: string;
    _exp: { [key: number]: number };
    _skills: number[];
    _equips: Game_Item[];
    _actionInputIndex: number;
    _lastMenuSkill: Game_Item;
    _lastBattleSkill: Game_Item;
    _lastCommandSymbol: string;
    _profile: string;
    _stateSteps: { [key: number]: number };

    constructor();
    initialize(): void;
    initialize(actorId: number): void;
    initMembers(): void;
    setup(actorId: number): void;
    actorId(): number;
    actor(): RPGMakerMV.DataActor;
    name(): string;
    setName(name: string): void;
    nickname(): string;
    setNickname(nickname: string): void;
    profile(): string;
    setProfile(profile: string): void;
    characterName(): string;
    characterIndex(): number;
    faceName(): string;
    faceIndex(): number;
    battlerName(): string;
    clearStates(): void;
    eraseState(stateId: number): void;
    resetStateCounts(stateId: number): void;
    initImages(): void;
    expForLevel(level: number): number;
    initExp(): void;
    currentExp(): number;
    currentLevelExp(): number;
    nextLevelExp(): number;
    nextRequiredExp(): number;
    maxLevel(): number;
    isMaxLevel(): number;
    initSkills(): void;
    initEquips(equips: number[]): void;
    equipSlots(): number[];
    equips(): Game_Item[];
    weapons(): RPGMakerMV.DataWeapon[];
    armors(): RPGMakerMV.DataArmor[];
    hasWeapon(weapon: RPGMakerMV.DataWeapon): boolean;
    hasArmor(armor: RPGMakerMV.DataArmor): boolean;
    isEquipChangeOk(slotId: number): boolean;
    changeEquip(slotId: number, item: RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor): void;
    forceChangeEquip(slotId: number, item: RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor): void;
    tradeItemWithParty(newItem: RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor, oldItem: RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor): boolean;
    changeEquipById(etypeId: number, itemId: number): void;
    isEquipped(item: RPGMakerMV.DataAnyItem): boolean;
    discardEquip(item: RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor): void;
    releaseUnequippableItems(forcing: boolean): void;
    clearEquipments(): void;
    optimizeEquipments(): void;
    bestEquipItem(slotId: number): RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor;
    calcEquipItemPerformance(item: RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor): number;
    isSkillWtypeOk(skill: RPGMakerMV.DataSkill): boolean;
    isWtypeEquipped(wtypeId: number): boolean;
    refresh(): void;
    isActor(): boolean;
    friendsUnit(): Game_Party;
    opponentsUnit(): Game_Troop;
    index(): number;
    isBattleMember(): boolean;
    isFormationChangeOk(): boolean;
    currentClass(): RPGMakerMV.DataClass;
    isClass(gameClass: RPGMakerMV.DataClass): boolean;
    skills(): RPGMakerMV.DataSkill[];
    usableSkills(): RPGMakerMV.DataSkill[];
    traitObjects(): RPGMakerMV.DataState[];
    attackElements(): number[];
    hasNoWeapons(): boolean;
    bareHandsElementId(): number;
    paramMax(paramId: number): number;
    paramBase(paramId: number): number;
    paramPlus(paramId: number): number;
    attackAnimationId1(): number;
    attackAnimationId2(): number;
    bareHandsAnimationId(): number;
    changeExp(exp: number, show: boolean): void;
    levelUp(): void;
    levelDown(): void;
    findNewSkills(lastSkills: RPGMakerMV.DataSkill[]): RPGMakerMV.DataSkill[];
    displayLevelUp(newSkills: RPGMakerMV.DataSkill[]): void;
    gainExp(exp: number): void;
    finalExpRate(): number;
    benchMembersExpRate(): number;
    shouldDisplayLevelUp(): boolean;
    changeLevel(level: number, show: boolean): void;
    learnSkill(skillId: number): void;
    forgetSkill(skillId: number): void;
    isLearnedSkill(skillId: number): boolean;
    hasSkill(skillId: number): boolean;
    changeClass(classId: number, keepExp: number): void;
    setCharacterImage(characterName: string, characterIndex: number): void;
    setFaceImage(faceName: string, faceIndex: number): void;
    setBattlerImage(battlerName: string): void;
    isSpriteVisible(): boolean;
    startAnimation(animationId: number, mirror: boolean, delay: number): void;
    performActionStart(aciton: Game_Action): void;
    performAction(aciton: Game_Action): void;
    performActionEnd(): void;
    performAttack(): void;
    performDamage(): void;
    performEvasion(): void;
    performMagicEvasion(): void;
    performCounter(): void;
    performCollapse(): void;
    performVictory(): void;
    performEscape(): void;
    makeActionList(): Game_Action[];
    makeAutoBattleActions(): void;
    makeConfusionActions(): void;
    makeActions(): void;
    onPlayerWalk(): void;
    updateStateSteps(state: RPGMakerMV.DataState): void;
    showAddedStates(): void;
    showRemovedStates(): void;
    stepsForTurn(): number;
    turnEndOnMap(): void;
    checkFloorEffect(): void;
    executeFloorDamage(): void;
    basicFloorDamage(): number;
    maxFloorDamage(): number;
    performMapDamage(): void;
    clearActions(): void;
    inputtingAction(): Game_Action;
    selectNextCommand(): boolean;
    selectPreviousCommand(): boolean;
    lastMenuSkill(): RPGMakerMV.DataSkill;
    setLastMenuSkill(skill: RPGMakerMV.DataSkill): void;
    lastBattleSkill(): RPGMakerMV.DataSkill;
    setLastBattleSkill(skill: RPGMakerMV.DataSkill): void;
    lastCommandSymbol(): string;
    setLastCommandSymbol(symbol: string): void;
    testEscape(item: RPGMakerMV.DataAnyItem): boolean;
    meetsUsableItemConditions(item: RPGMakerMV.DataAnyItem): boolean;
}

declare class Game_Enemy extends Game_Battler {
    _enemyId: number;
    _letter: string;
    _plural: boolean;
    _screenX: number;
    _screenY: number;

    constructor();
    initialize(): void;
    initialize(enemyId: number, x: number, y: number): void;
    initMembers(): void;
    setup(enemyId: number, x: number, y: number): void;
    isEnemy(): boolean;
    friendsUnit(): Game_Troop;
    opponentsUnit(): Game_Party;
    index(): number;
    isBattleMember(): boolean;
    enemyId(): number;
    enemy(): RPGMakerMV.DataEnemy;
    traitObjects(): RPGMakerMV.DataState[];
    paramBase(paramId: number): number;
    exp(): number;
    gold(): number;
    makeDropItems(): RPGMakerMV.DataAnyItem[];
    dropItemRate(): number;
    itemObject(kind: number, dataId: number): RPGMakerMV.DataAnyItem;
    isSpriteVisible(): boolean;
    screenX(): number;
    screenY(): number;
    battlerName(): string;
    battlerHue(): number;
    originalName(): string;
    name(): string;
    isLetterEmpty(): string;
    setLetter(letter: string): void;
    setPlural(plural: string): void;
    performActionStart(action: Game_Action): void;
    performAction(action: Game_Action): void;
    performActionEnd(): void;
    performDamage(): void;
    performCollapse(): void;
    transform(enemyId: number): void;
    meetsCondition(action: RPGMakerMV.Action): boolean;
    meetsTurnCondition(param1: number, param2: number): boolean;
    meetsHpCondition(param1: number, param2: number): boolean;
    meetsMpCondition(param1: number, param2: number): boolean;
    meetsStateCondition(param: number): boolean;
    meetsPartyLevelCondition(param: number): boolean;
    meetsSwitchCondition(param: number): boolean;
    isActionValid(action: RPGMakerMV.Action): boolean;
    selectAction(actionList: RPGMakerMV.Action[], ratingZero: number): RPGMakerMV.Action;
    selectAllActions(actionList: RPGMakerMV.Action[]): void;
    makeActions(): void;
}

declare class Game_Actors {
    _data: Game_Actor[];

    constructor();
    initialize(): void;
    actor(actorId: number): Game_Actor;
}

declare class Game_Unit {
    _inBattle: boolean;

    constructor();
    initialize(): void;
    inBattle(): boolean;
    members(): Game_Battler[];
    aliveMembers(): Game_Battler[];
    deadMembers(): Game_Battler[];
    movableMembers(): Game_Battler[];
    clearActions(): void;
    agility(): number;
    tgrSum(): number;
    randomTarget(): Game_Battler;
    randomDeadTarget(): Game_Battler;
    smoothTarget(): Game_Battler;
    smoothDeadTarget(): Game_Battler;
    clearResults(): void;
    onBattleStart(): void;
    onBattleEnd(): void;
    makeActions(): void;
    select(): void;
    isAllDead(): boolean;
    substituteBattler(): Game_Battler;
}

declare class Game_Party extends Game_Unit {
    static ABILITY_ENCOUNTER_HALF: 0;
    static ABILITY_ENCOUNTER_NONE: 1;
    static ABILITY_CANCEL_SURPRISE: 2;
    static ABILITY_RAISE_PREEMPTIVE: 3;
    static ABILITY_GOLD_DOUBLE: 4;
    static ABILITY_DROP_ITEM_DOUBLE: 5;

    _gold: number;
    _steps: number;
    _lastItem: Game_Item;
    _menuActorId: number;
    _targetActorId: number;
    _actors: number[];

    _items: { [key: number]: number };
    _weapons: { [key: number]: number };
    _armors: { [key: number]: number };

    constructor();
    initialize(): void;
    initAllItems(): void;
    exists(): boolean;
    size(): number;
    isEmpty(): boolean;
    members(): Game_Actor[];
    allMembers(): Game_Actor[];
    battleMembers(): Game_Actor[];
    maxBattleMembers(): number;
    leader(): Game_Actor;
    reviveBattleMembers(): Game_Actor[];
    items(): RPGMakerMV.DataItem[];
    weapons(): RPGMakerMV.DataWeapon[];
    armors(): RPGMakerMV.DataArmor[];
    equipItems(): Array<RPGMakerMV.DataWeapon | RPGMakerMV.DataArmor>;
    allItems(): RPGMakerMV.DataAnyItem[];
    itemContainer(item: RPGMakerMV.DataAnyItem): RPGMakerMV.DataItem[] | RPGMakerMV.DataWeapon[] | RPGMakerMV.DataArmor[];
    setupStartingMembers(): void;
    name(): string;
    setupBattleTest(): void;
    setupBattleTestMembers(): void;
    setupBattleTestItems(): void;
    highestLevel(): number;
    addActor(actorId: number): void;
    removeActor(actorId: number): void;
    gold(): number;
    gainGold(amount: number): void;
    loseGold(amount: number): void;
    maxGold(): number;
    steps(): number;
    increaseSteps(): void;
    numItems(item: RPGMakerMV.DataAnyItem): number;
    maxItems(item: RPGMakerMV.DataAnyItem): number;
    hasMaxItems(item: RPGMakerMV.DataAnyItem): boolean;
    hasItem(item: RPGMakerMV.DataAnyItem, includeEquip?: boolean): boolean;
    isAnyMemberEquipped(item: RPGMakerMV.DataAnyItem): boolean;
    gainItem(item: RPGMakerMV.DataAnyItem, amount: number, includeEquip: boolean): void;
    discardMembersEquip(item: RPGMakerMV.DataAnyItem, amount: number): void;
    loseItem(item: RPGMakerMV.DataAnyItem, amount: number, includeEquip: boolean): void;
    consumeItem(item: RPGMakerMV.DataAnyItem): void;
    canUse(item: RPGMakerMV.DataAnyItem): boolean;
    canInput(): boolean;
    isAllDead(): boolean;
    onPlayerWalk(): void;
    menuActor(): Game_Actor;
    setMenuActor(actor: Game_Actor): void;
    makeMenuActorNext(): void;
    makeMenuActorPrevious(): void;
    targetActor(): Game_Actor;
    setTargetActor(actor: Game_Actor): void;
    lastItem(): RPGMakerMV.DataAnyItem;
    setLastItem(item: RPGMakerMV.DataAnyItem): void;
    swapOrder(index1: number, index2: number): void;
    charactersForSavefile(): [string, number];
    facesForSavefile(): [string, number];
    partyAbility(abilityId: number): boolean;
    hasEncounterHalf(): boolean;
    hasEncounterNone(): boolean;
    hasCancelSurprise(): boolean;
    hasRaisePreemptive(): boolean;
    hasGoldDouble(): boolean;
    hasDropItemDouble(): boolean;
    ratePreemptive(troopAgi: number): number;
    rateSurprise(troopAgi: number): number;
    performVictory(): void;
    performEscape(): void;
    removeBattleStates(): void;
    requestMotionRefresh(): void;
}

declare class Game_Troop extends Game_Unit {
    static LETTER_TABLE_HALF: RPGMakerMV.DefaultLetterTableHalf;
    static LETTER_TABLE_FULL: RPGMakerMV.DefaultLetterTableFull;

    _interpreter: Game_Interpreter;
    _turnCount: number;
    _enemies: Game_Enemy[];
    _troopId: number;
    _eventFlags: { [key: number]: boolean };
    _namesCount: { [key: string]: number };

    constructor();
    initialize(): void;
    isEventRunning(): boolean;
    updateInterpreter(): void;
    turnCount(): number;
    members(): Game_Enemy[];
    clear(): void;
    troop(): RPGMakerMV.DataTroop;
    setup(troopId: number): void;
    makeUniqueNames(): void;
    letterTable(): string[];
    enemyNames(): string[];
    meetsConditions(page: RPGMakerMV.BattleEventPage): boolean;
    setupBattleEvent(): void;
    increaseTurn(): void;
    expTotal(): number;
    goldTotal(): number;
    goldRate(): number;
    makeDropItems(): RPGMakerMV.DataAnyItem[];
}

declare class Game_Map {
    _interpreter: Game_Interpreter;
    _mapId: number;
    _tilesetId: number;
    _events: Game_Event[];
    _commonEvents: Game_CommonEvent[];
    _vehicles: Game_Vehicle[];
    _displayX: number;
    _displayY: number;
    _nameDisplay: boolean;
    _scrollDirection: number;
    _scrollRest: number;
    _scrollSpeed: number;
    _parallaxName: string;
    _parallaxZero: boolean;
    _parallaxLoopX: boolean;
    _parallaxLoopY: boolean;
    _parallaxSx: number;
    _parallaxSy: number;
    _parallaxX: number;
    _parallaxY: number;
    _battleback1Name: string;
    _battleback2Name: string;
    _needsRefresh: boolean;

    constructor();
    initialize(): void;
    setup(mapId: number): void;
    isEventRunning(): boolean;
    tileWidth(): number;
    tileHeight(): number;
    mapId(): number;
    tilesetId(): number;
    displayX(): number;
    displayY(): number;
    parallaxName(): string;
    battleback1Name(): string;
    battleback2Name(): string;
    requestRefresh(mapId: number): void;
    isNameDisplayEnabled(): boolean;
    disableNameDisplay(): void;
    enableNameDisplay(): void;
    createVehicles(): void;
    refereshVehicles(): void;
    vehicles(): Game_Vehicle[];
    vehicle(type: string): Game_Vehicle;
    boat(): Game_Vehicle;
    ship(): Game_Vehicle;
    airship(): Game_Vehicle;
    setupEvents(): void;
    events(): Game_Event[];
    event(eventId: number): Game_Event;
    eraseEvent(eventId: number): void;
    parallelCommonEvents(): Game_CommonEvent[];
    setupScroll(): void;
    setupParallax(): void;
    setupBattleback(): void;
    setDisplayPos(x: number, y: number): void;
    parallaxOx(): number;
    parallaxOy(): number;
    tileset(): RPGMakerMV.DataTileset;
    tilesetFlags(): number[];
    displayName(): string;
    width(): number;
    height(): number;
    data(): number[];
    isLoopHorizontal(): boolean;
    isLoopVertical(): boolean;
    isDashDisabled(): boolean;
    encounterList(): RPGMakerMV.Encounter[];
    encounterStep(): number;
    isOverworld(): boolean;
    screenTileX(): number;
    screenTileY(): number;
    adjustX(x: number): number;
    adjustY(y: number): number;
    roundX(x: number): number;
    roundY(y: number): number;
    xWithDirection(x: number, d: number): number;
    yWithDirection(y: number, d: number): number;
    roundXWithDirection(x: number, d: number): number;
    roundYWithDirection(y: number, d: number): number;
    deltaX(x1: number, x2: number): number;
    deltaY(y1: number, y2: number): number;
    distance(x1: number, y1: number, x2: number, y2: number): number;
    canvasToMapX(x: number): number;
    canvasToMapY(y: number): number;
    autoplay(): void;
    refreshIfNeeded(): void;
    refresh(): void;
    refreshTileEvents(): void;
    eventsXy(x: number, y: number): Game_Event[];
    eventsXyNt(x: number, y: number): Game_Event[];
    tileEventsXy(x: number, y: number): Game_Event[];
    eventIdXy(x: number, y: number): number;
    scrollDown(distance: number): void;
    scrollLeft(distance: number): void;
    scrollRight(distance: number): void;
    scrollUp(distance: number): void;
    isValid(x: number, y: number): boolean;
    checkPassage(x: number, y: number): boolean;
    tileId(x: number, y: number, z: number): number;
    layeredTiles(x: number, y: number): number[];
    allTiles(x: number, y: number): number[];
    autotileType(x: number, y: number, z: number): number;
    isPassable(x: number, y: number, d: number): boolean;
    isBoatPassable(x: number, y: number): boolean;
    isShipPassable(x: number, y: number): boolean;
    isAirshipLandOk(x: number, y: number): boolean;
    checkLayeredTilesFlags(x: number, y: number, bit: number): boolean;
    isLadder(x: number, y: number): boolean;
    isBush(x: number, y: number): boolean;
    isCounter(x: number, y: number): boolean;
    isDamageFloor(x: number, y: number): boolean;
    terrainTag(x: number, y: number): number;
    regionId(x: number, y: number): number;
    startScroll(direction: number, distance: number, speed: number): void;
    isScrolling(): boolean;
    update(sceneActive: boolean): void;
    updateScroll(): void;
    scrollDistance(): number;
    doScroll(direction: number, distance: number): void;
    updateEvents(): void;
    updateVehicles(): void;
    updateParallax(): void;
    changeTileset(tilesetId: number): void;
    changeBattleback(battleback1Name: string, battleback2Name: string): void;
    changeParallax(name: string, loopX: number, loopY: number, sx: number, sy: number): void;
    updateInterpreter(): void;
    unlockEvent(eventId: number): void;
    setupStartingEvent(): boolean;
    setupTestEvent(): boolean;
    setupStartingMapEvent(): boolean;
    setupAutorunCommonEvent(): boolean;
    isAnyEventStarting(): boolean;
}

declare class Game_CommonEvent {
    _commonEventId: number;
    _interpreter: Game_Interpreter;

    constructor(commonEventId: number);
    initialize(commonEventId: number): void;
    event(): RPGMakerMV.DataCommonEvent;
    list(): RPGMakerMV.EventCommand[];
    refresh(): void;
    isActive(): boolean;
    update(): void;
}

declare class Game_CharacterBase {
    x: number;
    y: number;

    _x: number;
    _y: number;
    _realX: number;
    _realY: number;
    _moveSpeed: number;
    _moveFrequency: number;
    _opacity: number;
    _blendMode: number;
    _direction: number;
    _pattern: number;
    _priorityType: number;
    _tileId: number;
    _characterName: string;
    _characterIndex: number;
    _isObjectCharacter: boolean;
    _walkAnime: boolean;
    _stepAnime: boolean;
    _directionFix: boolean;
    _through: boolean;
    _transparent: boolean;
    _bushDepth: number;
    _animationId: number;
    _balloonId: number;
    _animationPlaying: boolean;
    _balloonPlaying: boolean;
    _animationCount: number;
    _stopCount: number;
    _jumpCount: number;
    _jumpPeak: number;
    _movementSuccess: boolean;

    constructor();
    initialize(): void;
    initMembers(): void;
    pos(x: number, y: number): boolean;
    posNt(x: number, y: number): boolean;
    moveSpeed(): number;
    setMoveSpeed(moveSpeed: number): void;
    moveFrequency(): number;
    setMoveFrequency(moveFrequency: number): void;
    opacity(): number;
    setOpacity(opacity: number): void;
    blendMode(): number;
    setBlendMode(blendMode: number): void;
    isNormalPriority(): boolean;
    setPriorityType(priorityType: number): void;
    isMoving(): boolean;
    isJumping(): boolean;
    jumpHeight(): number;
    isStopping(): boolean;
    checkStop(threshold: number): boolean;
    resetStopCount(): void;
    realMoveSpeed(): number;
    distancePerFrame(): number;
    isDashing(): boolean;
    isDebugThrough(): boolean;
    straighten(): void;
    reverseDir(d: number): number;
    canPass(x: number, y: number, d: number): boolean;
    canPassDiagonally(x: number, y: number, horz: number, vert: number): boolean;
    isMapPassable(x: number, y: number, d: number): boolean;
    isCollidedWithCharacters(x: number, y: number): boolean;
    isCollidedWithEvents(x: number, y: number): boolean;
    isCollidedWithVehicles(x: number, y: number): boolean;
    setPosition(x: number, y: number): void;
    copyPosition(character: Game_CharacterBase): void;
    locate(x: number, y: number): void;
    direction(): number;
    setDirection(d: number): void;
    isTile(): boolean;
    isObjectCharacter(): boolean;
    shiftY(): number;
    scrolledX(): number;
    scrolledY(): number;
    screenX(): number;
    screenY(): number;
    screenZ(): number;
    isNearTheScreen(): boolean;
    update(): void;
    updateStop(): void;
    updateJump(): void;
    updateMove(): void;
    updateAnimation(): void;
    animationWait(): number;
    updateAnimationCount(): void;
    updatePattern(): void;
    maxPattern(): number;
    pattern(): number;
    setPattern(pattern: number): void;
    isOriginalPattern(): boolean;
    resetPattern(): void;
    refreshBushDepth(): void;
    isOnLadder(): boolean;
    isOnBush(): boolean;
    terrainTag(): boolean;
    regionId(): boolean;
    increaseSteps(): void;
    tileId(): void;
    characterName(): string;
    characterIndex(): number;
    setImage(characterName: string, characterIndex: number): void;
    setTileImage(tileId: number): void;
    checkEventTriggerTouchFront(d: number): void;
    checkEventTriggerTouch(x: number, y: number): boolean;
    isMovementSucceeded(x: number, y: number): boolean;
    setMovementSuccess(success: boolean): void;
    moveStraight(d: number): void;
    moveDiagonally(horz: number, vert: number): void;
    jump(xPlus: number, yPlus: number): void;
    hasWalkAnime(): boolean;
    setWalkAnime(walkAnime: boolean): void;
    hasStepAnime(): boolean;
    setStepAnime(stepAnime: boolean): void;
    isDirectionFixed(): boolean;
    setDirectionFix(directionFix: boolean): void;
    isThrough(): boolean;
    setThrough(through: boolean): void;
    isTransparent(): boolean;
    bushDepth(): number;
    setTransparent(transparent: boolean): void;
    requestAnimation(animationId: number): void;
    requestBalloon(balloonId: number): void;
    animationId(): number;
    balloonId(): number;
    startAnimation(): void;
    startBalloon(): void;
    isAnimationPlaying(): boolean;
    isBalloonPlaying(): boolean;
    endAnimation(): void;
    endBalloon(): void;
}

declare class Game_Character extends Game_CharacterBase {
    static ROUTE_END: 0;
    static ROUTE_MOVE_DOWN: 1;
    static ROUTE_MOVE_LEFT: 2;
    static ROUTE_MOVE_RIGHT: 3;
    static ROUTE_MOVE_UP: 4;
    static ROUTE_MOVE_LOWER_L: 5;
    static ROUTE_MOVE_LOWER_R: 6;
    static ROUTE_MOVE_UPPER_L: 7;
    static ROUTE_MOVE_UPPER_R: 8;
    static ROUTE_MOVE_RANDOM: 9;
    static ROUTE_MOVE_TOWARD: 10;
    static ROUTE_MOVE_AWAY: 11;
    static ROUTE_MOVE_FORWARD: 12;
    static ROUTE_MOVE_BACKWARD: 13;
    static ROUTE_JUMP: 14;
    static ROUTE_WAIT: 15;
    static ROUTE_TURN_DOWN: 16;
    static ROUTE_TURN_LEFT: 17;
    static ROUTE_TURN_RIGHT: 18;
    static ROUTE_TURN_UP: 19;
    static ROUTE_TURN_90D_R: 20;
    static ROUTE_TURN_90D_L: 21;
    static ROUTE_TURN_180D: 22;
    static ROUTE_TURN_90D_R_L: 23;
    static ROUTE_TURN_RANDOM: 24;
    static ROUTE_TURN_TOWARD: 25;
    static ROUTE_TURN_AWAY: 26;
    static ROUTE_SWITCH_ON: 27;
    static ROUTE_SWITCH_OFF: 28;
    static ROUTE_CHANGE_SPEED: 29;
    static ROUTE_CHANGE_FREQ: 30;
    static ROUTE_WALK_ANIME_ON: 31;
    static ROUTE_WALK_ANIME_OFF: 32;
    static ROUTE_STEP_ANIME_ON: 33;
    static ROUTE_STEP_ANIME_OFF: 34;
    static ROUTE_DIR_FIX_ON: 35;
    static ROUTE_DIR_FIX_OFF: 36;
    static ROUTE_THROUGH_ON: 37;
    static ROUTE_THROUGH_OFF: 38;
    static ROUTE_TRANSPARENT_ON: 39;
    static ROUTE_TRANSPARENT_OFF: 40;
    static ROUTE_CHANGE_IMAGE: 41;
    static ROUTE_CHANGE_OPACITY: 42;
    static ROUTE_CHANGE_BLEND_MODE: 43;
    static ROUTE_PLAY_SE: 44;
    static ROUTE_SCRIPT: 45;

    _moveRouteForcing: boolean;
    _moveRoute: RPGMakerMV.MoveRoute;
    _moveRouteIndex: number;
    _originalMoveRoute: RPGMakerMV.MoveRoute;
    _originalMoveRouteIndex: number;
    _waitCount: number;

    constructor();
    initialize(): void;
    initMembers(): void;
    memorizeMoveRoute(): void;
    restoreMoveRoute(): void;
    isMoveRouteForcing(): boolean;
    setMoveRoute(moveRoute: RPGMakerMV.MoveRoute): void;
    forceMoveRoute(moveRoute: RPGMakerMV.MoveRoute): void;
    updateStop(): void;
    updateRoutineMove(): void;
    processMoveCommand(command: RPGMakerMV.MoveCommand): void
    deltaXFrom(x: number): number;
    deltaYFrom(y: number): number;
    moveRandom(): void;
    moveTowardCharacter(character: Game_CharacterBase): void;
    moveAwayFromCharacter(character: Game_CharacterBase): void;
    turnTowardCharacter(character: Game_CharacterBase): void;
    turnAwayFromCharacter(character: Game_CharacterBase): void;
    turnTowardPlayer(): void;
    turnAwayFromPlayer(): void;
    moveTowardPlayer(): void;
    moveAwayFromPlayer(): void;
    moveForward(): void;
    moveBackward(): void;
    processRouteEnd(): void;
    advanceMoveRouteIndex(): void;
    turnRight90(): void;
    turnLeft90(): void;
    turn180(): void;
    turnRightOrLeft90(): void;
    turnRandom(): void;
    findDirectionTo(goalX: number, goalY: number): number;
    searchLimit(): number;
}

declare class Game_Player extends Game_Character {
    _vehicleType: string;
    _vehicleGettingOn: boolean;
    _vehicleGettingOff: boolean;
    _dashing: boolean;
    _needsMapReload: boolean;
    _transferring: boolean;
    _newMapId: number;
    _newX: number;
    _newY: number;
    _newDirection: number;
    _fadeType: number;
    _followers: Game_Followers;
    _encounterCount: number;

    constructor();
    initialize(): void;
    initMembers(): void;
    clearTransferInfo(): void;
    followers(): Game_Followers;
    refresh(): void;
    isStopping(): boolean;
    reserveTransfer(mapId: number, x: number, y: number, d: number, fadeType: number): void;
    requestMapReload(): void;
    isTransferring(): boolean;
    newMapId(): number;
    fadeType(): number;
    performTransfer(): void;
    isMapPassable(x: number, y: number, d: number): boolean;
    vehicle(): RPGMakerMV.Vehicle;
    isInBoat(): boolean;
    isInShip(): boolean;
    isInAirship(): boolean;
    isInVehicle(): boolean;
    isNormal(): boolean;
    isDashing(): boolean;
    isDebugThrough(): boolean;
    isCollided(x: number, y: number): boolean;
    centerX(): number;
    centerY(): number;
    center(x: number, y: number): void;
    locate(x: number, y: number): void;
    increaseSteps(): void;
    makeEncounterCount(): void;
    makeEncounterTroopId(): number;
    meetsEncounterConditions(encounter: RPGMakerMV.Encounter): boolean;
    executeEncounter(): boolean;
    startMapEvent(x: number, y: number, triggers: number[], normal: boolean): void;
    moveByInput(): void;
    canMove(): boolean;
    getInputDirection(): number;
    executeMove(direction: number): void;
    update(): void;
    update(sceneActive: boolean): void;
    updateDashing(): void;
    isDashButtonPressed(): boolean;
    updateScroll(lastScrolledX: number, lastScrolledY: number): void;
    updateVehicle(): void;
    updateVehicleGetOn(): void;
    updateVehicleGetOff(): void;
    updateNonmoving(wasMoving: boolean): void;
    triggerAction(): boolean;
    triggerButtonAction(): boolean;
    triggerTouchAction(): boolean;
    triggerTouchActionD1(x1: number, y1: number): boolean;
    triggerTouchActionD2(x2: number, y2: number): boolean;
    triggerTouchActionD3(x2: number, y2: number): boolean;
    updateEncounterCount(): void;
    canEncounter(): boolean;
    encounterProgressValue(): number;
    checkEventTriggerHere(triggers: number[]): void;
    checkEventTriggerThere(triggers: number[]): void;
    checkEventTriggerTouch(x: number, y: number): boolean;
    checkEventTriggerTouch(x: number, y: number): void;
    canStartLocalEvents(): boolean;
    getOnOffVehicle(): boolean;
    getOnVehicle(): boolean;
    getOffVehicle(): boolean;
    forceMoveForward(): void;
    isOnDamageFloor(): boolean;
    moveStraight(): void;
    moveDiagonally(): void;
    jump(xPlus: number, yPlus: number): void;
    showFollowers(): void;
    hideFollowers(): void;
    gatherFollowers(): void;
    areFollowersGathering(): boolean;
    areFollowersGathered(): boolean;
}

declare class Game_Follower extends Game_Character {
    _memberIndex: number;

    constructor();
    initialize(): void;
    refresh(): void;
    actor(): Game_Actor;
    isVisible(): boolean;
    update(): void;
    chaseCharacter(character: Game_CharacterBase): void;
}

declare class Game_Followers extends Game_Character {
    _visible: boolean;
    _gathering: boolean;
    _data: Game_Follower[];

    constructor();
    initialize(): void;
    isVisible(): boolean;
    show(): void;
    hide(): void;
    follower(index: number): Game_Follower;
    forEach(callback: Function, thisObject: this): void;
    reverseEach(callback: Function, thisObject: this): void;
    refresh(): void;
    update(): void;
    updateMove(): void;
    jumpAll(): void;
    synchronize(x: number, y: number, d: number): void;
    gather(): void;
    areGathering(): boolean;
    visibleFollowers(): boolean;
    areMoving(): boolean;
    areGathered(): boolean;
    isSomeoneCollided(): boolean;
}

declare class Game_Vehicle extends Game_Character {
    _type: string;
    _mapId: number;
    _altitude: number;
    _driving: boolean;
    _bgm: IAudioObject;

    constructor();
    initialize(): void;
    initMembers(): void;
    isBoat(): boolean;
    isShip(): boolean;
    isAirship: boolean;
    resetDirection(): void;
    initMoveSpeed(): void;
    vehicle(): Game_Vehicle;
    loadSystemSettings(): void;
    refresh(): void;
    setLocation(mapId: number, x: number, y: number): void;
    pos(x: number, y: number): boolean;
    isMapPassable(x: number, y: number, d: number): boolean;
    getOn(): void;
    getOff(): void;
    setBgm(bgm: IAudioObject): void;
    playBgm(): void;
    syncWithPlayer(): void;
    screenY(): number;
    shadowX(): number;
    shadowY(): number;
    shadowOpacity(): number;
    canMove(): boolean;
    update(): void;
    updateAirship(): void;
    updateAirshipAltitude(): void;
    maxAltitude(): number;
    isLowest(): boolean;
    isHighest(): boolean;
    isTakeoffOk(): boolean;
    isLandOk(x: number, y: number, d: number): boolean;
}

declare class Game_Event extends Game_Character {
    _mapId: number;
    _eventId: number;
    _moveType: number;
    _trigger: number;
    _starting: boolean;
    _erased: boolean;
    _pageIndex: number;
    _originalPattern: number;
    _originalDirection: number;
    _prelockDirection: number;
    _locked: boolean;
    _interpreter: Game_Interpreter;

    constructor();
    constructor(mapId: number, eventId: number);
    initialize(): void;
    initialize(mapId: number, eventId: number): void;
    initMembers(): void;
    eventId(): number;
    event(): RPGMakerMV.MapEvent;
    page(): RPGMakerMV.MapEventPage;
    list(): RPGMakerMV.EventCommand[];
    isCollidedWithCharacters(): boolean;
    isCollidedWithEvents(): boolean;
    isCollidedWithPlayerCharacters(): boolean;
    lock(): void;
    unlock(): void;
    updateStop(): void;
    updateSelfMovement(): void;
    stopCountThreshold(): number;
    moveTypeRandom(): void;
    moveTypeTowardPlayer(): void;
    isNearThePlayer(): number;
    moveTypeCustom(): void;
    isStarting(): boolean;
    clearStartingFlag(): void;
    isTriggerIn(triggers: number[]): boolean;
    start(): void;
    erase(): void;
    refresh(): void;
    findProperPageIndex(): number;
    meetsConditions(page: RPGMakerMV.MapEventPage): boolean;
    setupPage(): void;
    clearPageSettings(): void;
    setupPageSettings(): void;
    isOriginalPattern(): boolean;
    resetPattern(): void;
    checkEventTriggerTouch(x: number, y: number): void;
    checkEventTriggerTouch(x: number, y: number): boolean;
    checkEventTriggerAuto(): void;
    update(): void;
    updateParallel(): void;
    locate(x: number, y: number): void;
    forceMoveRoute(moveRoute: RPGMakerMV.MoveRoute): void;
}

declare class Game_Interpreter {
    _depth: number;
    _branch: { [key: number]: number };
    _params: any[];
    _indent: number;
    _frameCount: number;
    _freezeChecker: number;
    _mapId: number;
    _eventId: number;
    _list: RPGMakerMV.EventCommand[];
    _index: number;
    _waitCount: number;
    _waitMode: string;
    _comments: string;
    _childInterpreter: Game_Interpreter;
    _character: Game_Character;

    constructor(depth?: number);
    initialize(depth?: number): void;
    checkOverflow(): void;
    clear(): void;
    setup(list: RPGMakerMV.EventCommand[], eventId?: number): void;
    eventId(): number;
    isOnCurrentMap(): boolean;
    setupReservedCommonEvent(): boolean;
    isRunning(): boolean;
    update(): void;
    updateChild(): boolean;
    updateWait(): boolean;
    updateWaitCount(): boolean;
    updateWaitMode(): boolean;
    setWaitMode(waitMode: string): void;
    wait(duration: number): void;
    fadeSpeed(): number;
    executeCommand(): boolean;
    checkFreeze(): boolean;
    terminate(): void;
    skipBranch(): void;
    currentCommand(): RPGMakerMV.EventCommand;
    nextEventCode(): number;
    iterateActorId(param: number, callback: RPGMakerMV.ActorIteratorCallback): void;
    iterateActorEx(param1: number, param2: number, callback: RPGMakerMV.ActorIteratorCallback): void;
    iterateActorIndex(param: number, callback: RPGMakerMV.ActorIteratorCallback): void;
    iterateEnemyIndex(param: number, callback: RPGMakerMV.EnemyIteratorCallback): void;
    iterateBattler(param1: number, param2: number, callback: Function): void;
    character(param: number): Game_Character;
    operateValue(operation: number, operandType: number, operand: number): number;
    changeHp(target: Game_Battler, value: number, allowDeath: boolean): void;
    command101(): boolean;
    command102(): boolean;
    setupChoices(params: [string[], number, number?, number?, number?]): void;
    command402(): boolean;
    command403(): boolean;
    command103(): boolean;
    setupNumInput(params: [number, number]): void;
    command104(): boolean;
    setupItemChoice(params: [number, number]): void;
    command105(): boolean;
    command108(): boolean;
    command111(): boolean;
    command411(): boolean;
    command112(): boolean;
    command413(): boolean;
    command113(): boolean;
    command115(): boolean;
    command117(): boolean;
    setupChild(list: RPGMakerMV.EventCommand[], eventId: number): void;
    command118(): boolean;
    command119(): boolean;
    jumpTo(index: number): void;
    command121(): boolean;
    command122(): boolean;
    gameDataOperand(type: number, param1: number, param2: number): number;
    operateVariable(variableId: number, operationType: number, value: number): void;
    command123(): boolean;
    command124(): boolean;
    command125(): boolean;
    command126(): boolean;
    command127(): boolean;
    command128(): boolean;
    command129(): boolean;
    command132(): boolean;
    command133(): boolean;
    command134(): boolean;
    command135(): boolean;
    command136(): boolean;
    command137(): boolean;
    command138(): boolean;
    command139(): boolean;
    command140(): boolean;
    command201(): boolean;
    command202(): boolean;
    command203(): boolean;
    command204(): boolean;
    command205(): boolean;
    command206(): boolean;
    command211(): boolean;
    command212(): boolean;
    command213(): boolean;
    command214(): boolean;
    command216(): boolean;
    command217(): boolean;
    command221(): boolean;
    command222(): boolean;
    command223(): boolean;
    command224(): boolean;
    command225(): boolean;
    command230(): boolean;
    command231(): boolean;
    command232(): boolean;
    command233(): boolean;
    command234(): boolean;
    command235(): boolean;
    command236(): boolean;
    command241(): boolean;
    command242(): boolean;
    command243(): boolean;
    command244(): boolean;
    command245(): boolean;
    command246(): boolean;
    command249(): boolean;
    command250(): boolean;
    command251(): boolean;
    command261(): boolean;
    videoFileExt(): string;
    command281(): boolean;
    command282(): boolean;
    command283(): boolean;
    command284(): boolean;
    command285(): boolean;
    command301(): boolean;
    command601(): boolean;
    command602(): boolean;
    command603(): boolean;
    command302(): boolean;
    command302(): boolean;
    command311(): boolean;
    command312(): boolean;
    command326(): boolean;
    command313(): boolean;
    command314(): boolean;
    command315(): boolean;
    command316(): boolean;
    command317(): boolean;
    command318(): boolean;
    command319(): boolean;
    command320(): boolean;
    command321(): boolean;
    command322(): boolean;
    command323(): boolean;
    command324(): boolean;
    command325(): boolean;
    command331(): boolean;
    command332(): boolean;
    command342(): boolean;
    command333(): boolean;
    command334(): boolean;
    command335(): boolean;
    command336(): boolean;
    command337(): boolean;
    command339(): boolean;
    command340(): boolean;
    command351(): boolean;
    command352(): boolean;
    command353(): boolean;
    command354(): boolean;
    command355(): boolean;
    command356(): boolean;
    pluginCommand(command: string, args: string[]): void;
    static requestImages(list: RPGMakerMV.EventCommand[], commonList: number[]): void;
}
